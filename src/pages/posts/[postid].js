import Avatar from "@/components/common/avatar/avatar";
import HomeLeft from "@/components/home/homeLeft/HomeLeft";
import HomeRight from "@/components/home/homeRight/HomeRight";
import CommentBox from "@/components/modalComponents/CommentBox";
import Tweet from "@/components/tweet/tweet";
import connectMongo from "@/db/dbConnect";

import { useRouter } from "next/router";
import React, { useState } from "react";
import style from "../../components/tweet/tweet.module.css";
import Button from "@/components/common/button/button";
import Head from "next/head";
// import CommentDB from "@/db/models/commentModel";
import Comments from "@/components/common/comment/Comments";
import mongoose from "mongoose";
import { useSession } from "next-auth/react";
import PostOption from "@/components/home/homeRight/postOption/PostOption";
import ModalComponent from "@/components/modal/ModalComponent";
import Post from "@/components/common/post/post";
import TweetDBV2 from "@/db/modelsV2/tweetModelV2";
// import PostDB from "@/db/models/postModel";

export async function getServerSideProps(context) {
  const { postid } = context.params;
  // const postid = "6433b1a3f29fc1fe4788ccbf";
  let post = null;
  let comments = null;
  try {
    await connectMongo();

    if (postid != "undefined") {
      //
      // post = await PostDB.findById(postid).populate({
      //   path: "owner",
      //   select: { follower: 0, following: 0 },
      // });

      // comments = await CommentDB.findOne({ head: postid }).populate({
      //   path: "nodes",
      //   populate: {
      //     path: "owner",
      //     select: { follower: 0, following: 0 },
      //   },
      // });

      // const promises = await Promise.all([
      //   TweetDBV2.findById(postid).populate({
      //     path: "owner",
      //     select: { follower: 0, following: 0 },
      //   }),
      //   TweetDBV2.findo({
      //     head: postid,
      //     type: "comment",
      //   })
      //     .populate({
      //     path: "commentsList",
      //     populate: {
      //       path: "owner",
      //       select: { follower: 0, following: 0 },
      //     },
      //   }),
      // ]);

      const postDB = await TweetDBV2.findById(postid)
        .populate({ path: "owner", select: "_id username email image" })
        .populate({
          path: "commentsList",
          // select: "tweetText",
          populate: {
            path: "owner",
            select: "username image email _id",
          },
          sort: { createdAt: -1 },
          limit: 20,
          options: { sort: { createdAt: -1 }, limit: 20 },
        });
      // post = promises[0];
      // comments = promises[1];
      comments = postDB.commentsList;
      post = postDB;
    }
  } catch (error) {}

  return {
    props: { tweet: JSON.stringify(post), comments: JSON.stringify(comments) },
  };
}

export default function PostId({ tweet, comments }) {
  const router = useRouter();
  const curPath = router.asPath;
  const [showEdit, setShowEdit] = useState(false);
  const session = useSession();
  const tweetN = JSON.parse(tweet);
  const commentN = JSON.parse(comments);

  return (
    <>
      <Head>
        <title>Twitter</title>
        <meta name="description" content="Generated by create next app" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/fav2.ico" />
      </Head>
      {router.query.modal == "edit-tweet" && (
        <ModalComponent returnTo={"/posts/" + tweetN._id}>
          <Post returnTo={"/posts/" + tweetN._id} tweetData={tweetN}></Post>
        </ModalComponent>
      )}
      <main className="main">
        <HomeLeft />
        <div>
          <div className="glassPortion">
            {tweetN && (
              <h2>
                {tweetN.type.charAt(0).toUpperCase() + tweetN.type.slice(1)} of{" "}
                {tweetN.owner.username}
              </h2>
            )}
          </div>
          {tweetN && (
            <Tweet
              padding="3rem 1rem 1rem 1rem"
              showCommentIcon={false}
              tweet={tweetN}
            ></Tweet>
          )}
          {tweetN && (
            <CommentBox btnTxt="Comment" head={tweetN._id}></CommentBox>
          )}
          {commentN?.map((comment, index) => {
            return (
              <div key={comment._id}>
                <Comments comment={comment}></Comments>
              </div>
            );
          })}
          {/* <div>{tweet}</div>
                    <hr />
                    <div>{comments}</div> */}
        </div>
        {tweetN && (
          <HomeRight
            show={tweetN.owner._id == session.data?.user.id && "PostOption"}
          >
            {tweetN.owner._id == session.data?.user.id && (
              <PostOption postid={tweetN._id} tweet={tweetN}></PostOption>
            )}
          </HomeRight>
        )}
        <style jsx>{`
          .glassPortion {
            display: inline-block;
            backdrop-filter: blur(4px);
            position: sticky;
            top: 0;
            width: 100%;
            height: 100px;
            /* left: 0;
    height: 100px;
    width: 100%;
    width: calc(var(--main-width) - 2px);
    left: 50%;
    transform: translateX(-50%); */
            background-color: var(--bg-op);
            z-index: 2;

            padding: 1rem;
          }
          .main {
            width: 100%;
            height: 100vh;
            height: 100dvh;
            display: grid;
            grid-template-columns: 1fr var(--main-width) 1fr;
            column-gap: 1rem;
          }

          .vLine {
            margin-top: auto;
            margin-bottom: auto;
            margin-left: auto;
            margin-right: auto;
            width: 2px;
            height: 70%;
            background-color: #1d9cf05d;
          }
        `}</style>
      </main>
    </>
  );
}

// return { props: { tweet: JSON.parse(JSON.stringify(post)), comments: JSON.parse(JSON.stringify(comments)) } }
